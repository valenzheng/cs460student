<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Assignment 4: flashy fish!</title>
    <style>
      html, body { 
        background-color:#000;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
        background: url('https://cs460.org/assignments/04/bg.jpg'); /* part 10: add backgroundc*/
        background-size: cover;
      }

      #c {
        width: 100%;
        height: 100%;
        background-color: transparent;
      }
    </style>
  </head>
  <script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>
  
  <script id="vertexshader" type="glsl">
    attribute vec3 a_position;

    uniform mat4 u_transform;
    uniform float u_pointsize;

    void main(void) {
      vec4 final_position = u_transform * vec4( a_position, 1.0 );            
      gl_Position = final_position;
      gl_PointSize = u_pointsize;
    }
  </script>
  
  <script id="fragmentshader" type="glsl">
    precision mediump float;

    uniform vec4 u_color;

    void main(void) {
      gl_FragColor = u_color;
    }
  </script>
  
  <script>
    var c, gl;
    var v_shader, f_shader, shaderprogram;
    var vertices, indices, v_buffer, i_buffer;
    var mouseNDC = { x: 0, y: 0 };
    const followSpeed = 0.05;

    window.onload = function() {
      // INITIALIZE WEBGL
      c = document.getElementById( 'c' ); 
      c.width = window.innerWidth;
      c.height = window.innerHeight;

      gl = c.getContext( 'webgl' ); 
      gl.viewport(0, 0, c.width, c.height );

      // SHADERS
      v_shader = gl.createShader( gl.VERTEX_SHADER );
      f_shader = gl.createShader( gl.FRAGMENT_SHADER );
      
      gl.shaderSource( v_shader, document.getElementById( 'vertexshader' ).innerText );
      gl.compileShader( v_shader );
      if (!gl.getShaderParameter( v_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( v_shader ));
      }

      gl.shaderSource( f_shader, document.getElementById( 'fragmentshader' ).innerText );
      gl.compileShader( f_shader );
      if (!gl.getShaderParameter( f_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( f_shader ));
      }

      shaderprogram = gl.createProgram();
      gl.attachShader( shaderprogram, v_shader );
      gl.attachShader( shaderprogram, f_shader );
      gl.linkProgram( shaderprogram );
      gl.useProgram( shaderprogram );

      // mouse move listener
      c.addEventListener('mousemove', updateMousePosition);

      all_fish = [];
      // part 11: flip big fish (direction = -1)
      all_fish.push( createFish( new Float32Array([0,0,0]), new Float32Array([1.,0.,0.,1.]), 1, -1) );
      
      // part 4: add 100 small fish (random color/offset/scale)
      for (let i = 0; i < 100; i++) {
        random_color = [Math.random(),Math.random(),Math.random(),Math.random()];
        random_offset = [Math.random()-Math.random(), Math.random()-Math.random(), 0];
        random_scale = Math.random() * 0.3;
        all_fish.push(createFish(random_offset, random_color, random_scale, 1));
      }

      animate();
    };

    // update mouse position
    function updateMousePosition(e) {
      const rect = c.getBoundingClientRect();
      mouseNDC.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouseNDC.y = 1 - ((e.clientY - rect.top) / rect.height) * 2;
    }

    // sollision detection
    function checkCollision(bigFishOffset, bigFishScale, smallFishOffset, smallFishScale) {
      const bigFishRadius = bigFishScale * 0.5;
      const smallFishRadius = smallFishScale * 0.5;
      const dx = bigFishOffset[0] - smallFishOffset[0];
      const dy = bigFishOffset[1] - smallFishOffset[1];
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance <= bigFishRadius + smallFishRadius;
    }

    // part 1: change createRectangle to createFish
    function createFish(offset, color, scale = 1, direction = 1) {
      var vertices = new Float32Array([
         0.5,  0.0, 0.0,   // 0: nose
         0.2,  0.25, 0.0,  // 1: upper body
        -0.2,  0.15, 0.0,  // 2: upper tail base
        -0.4,  0.3, 0.0,   // 3: upper tail tip
        -0.4, -0.3, 0.0,   // 4: lower tail tip
        -0.2, -0.15, 0.0,  // 5: lower tail base
         0.2, -0.25, 0.0   // 6: lower body
      ]);

      var indices = new Uint8Array([
        0, 1, 6,  // main body
        1, 2, 6,  // upper mid-body
        2, 5, 6,  // rear body
        2, 3, 5,  // tail top
        3, 4, 5   // tail fin
      ]); 

      // vertex buffer for fish body
      var v_buffer = gl.createBuffer();
      gl.bindBuffer( gl.ARRAY_BUFFER, v_buffer );
      gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
      gl.bindBuffer( gl.ARRAY_BUFFER, null );

      // index buffer for fish body
      var i_buffer = gl.createBuffer();
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, i_buffer );
      gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW );
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null );
      
      // part 2: eye buffer (flip y if direction = -1)
      var eye_vertex;
      if (direction == -1) {
        eye_vertex = new Float32Array([0.2, -0.2, 0.0]);
      } else {
        eye_vertex = new Float32Array([0.2, 0.2, 0.0]);
      }

      var eye_v_buffer = gl.createBuffer(); 
      gl.bindBuffer( gl.ARRAY_BUFFER, eye_v_buffer );
      gl.bufferData( gl.ARRAY_BUFFER, eye_vertex, gl.STATIC_DRAW );
      gl.bindBuffer( gl.ARRAY_BUFFER, null );

      return [v_buffer, i_buffer, eye_v_buffer, color, offset, scale, direction];
    };

    // animate function
    function animate() {
      requestAnimationFrame(animate);
      gl.clearColor( 0., 0., 0., 0.)
      gl.clear( gl.COLOR_BUFFER_BIT );

      // part 9: enable transparency
      gl.enable(gl.BLEND);
      gl.blendEquation(gl.FUNC_ADD);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.disable(gl.DEPTH_TEST);
      
      // big fish data
      const bigFish = all_fish[0];
      const bigFishOffset = bigFish[4];
      const bigFishScale = bigFish[5];

      // smooth follow for big fish
      bigFishOffset[0] += (mouseNDC.x - bigFishOffset[0]) * followSpeed;
      bigFishOffset[1] += (mouseNDC.y - bigFishOffset[1]) * followSpeed;

      for( var r = 0; r < all_fish.length; r++ ) {
        var current_buffers = all_fish[r];
        var current_v_buffer = current_buffers[0];
        var current_i_buffer = current_buffers[1];
        var current_eye_v_buffer = current_buffers[2];
        var current_color = current_buffers[3];
        var current_offset = current_buffers[4];
        var current_scale = current_buffers[5];
        var current_direction = current_buffers[6];

        // part 5: small fish movement
        if (r !== 0) { 
          current_offset[0] += 0.01;
          current_offset[1] += 0.1*Math.random();
          current_offset[1] -= 0.1*Math.random();
          if (current_offset[0] >= 1) current_direction = -1;
          if (current_offset[0] <= -1) current_direction = 1;
          current_offset[0] *= current_direction;
        }

        // part 6, 7 and 8: transformation matrix (rotation + scale + translation)
        var theta = Math.random() * 10 * Math.PI / 180; 
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);
        var transform = [
          current_direction * current_scale * cosTheta,  
          current_scale * sinTheta, 0, 0,  
          -current_scale * sinTheta,  
          current_direction * current_scale * cosTheta, 0, 0,  
          0, 0, current_direction * current_scale * 1, 0,  
          current_offset[0], current_offset[1], current_offset[2], 1
        ];

        var u_transform = gl.getUniformLocation( shaderprogram, 'u_transform' );
        gl.uniformMatrix4fv( u_transform, false, new Float32Array(transform) );

        // connect fish body geometry to shader
        gl.bindBuffer( gl.ARRAY_BUFFER, current_v_buffer );
        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, current_i_buffer );
        var a_position = gl.getAttribLocation( shaderprogram, 'a_position' );
        gl.vertexAttribPointer( a_position, 3, gl.FLOAT, false, 0, 0 );
        gl.enableVertexAttribArray ( a_position );

        // part 12: color logic
        var t = performance.now() * 0.001;
        var a = 0.6 + 0.4 * Math.sin(t * 2.0);
        var updated_color;
        const isColliding = r !== 0 && checkCollision(bigFishOffset, bigFishScale, current_offset, current_scale);

        if (r == 0) { 
          // part 11: big fish stays red
          updated_color = new Float32Array([1, 0, 0, .7]);
        } else if (isColliding) {
          // bonus: pulsating opaque pink:
          updated_color = new Float32Array([
            0.9 + 0.08*Math.sin(t + 0.0),
            0.5 + 0.08*Math.sin(t + 2.0),
            0.7 + 0.08*Math.sin(t + 4.0),
            1.0 
          ]);
        } else { 
          // part 12: blue pulsating color
          updated_color = new Float32Array([
            0.3 + 0.2*Math.sin(t + 0.0), 
            0.6 + 0.2*Math.sin(t + 2.0),
            0.9 + 0.1*Math.sin(t + 4.0),
            a
          ]);
        }

        // set final color
        var u_color = gl.getUniformLocation( shaderprogram, 'u_color' );
        gl.uniform4fv( u_color, updated_color );

        // draw fish body (15 indices)
        gl.drawElements( gl.TRIANGLES, 15, gl.UNSIGNED_BYTE, 0);

        // part 3: render eye
        gl.uniform4fv( u_color, new Float32Array([0, 0, 0, .5]) );
        var u_pointsize = gl.getUniformLocation( shaderprogram, 'u_pointsize' );
        gl.uniform1fv( u_pointsize, new Float32Array([current_scale * 20.]) );
        gl.enableVertexAttribArray( a_position );
        gl.bindBuffer( gl.ARRAY_BUFFER, current_eye_v_buffer );
        gl.vertexAttribPointer( a_position, 3, gl.FLOAT, false, 0, 0 );
        gl.drawArrays( gl.POINTS, 0, 1 );
      }
    };
  </script>
  <body>
    <canvas id="c"></canvas>
  </body>
</html>
